# 信息安全CIA

当今信息技术高速发展，信息安全越来越重要。信息安全是指保护完整可靠的数据仅能被授权访问，其包含三要素CIA：机密性（**C**onfidentiality）、完整性（**I**ntegrity）、可用性（**A**vailability）。

- 机密性：信息不为其他未授权的个人或团体获得

- 完整性：保证信息在传输、存储、使用的过程中，不被未经授权的修改

- 可用性：被授权访问信息的主体，在需要信息时能及时访问到

这里以举一个例子解释一下：比如要保护家里的资产（冰箱、洗衣机、电视等）。

- 左图将门窗封死，可以保证机密性：外人不能进入并知晓家里的状况；可以保证完整性，家里东西的不会被改变；无法保证可用性，自家人也不能进入。
- 中图给门上锁，可以保证机密性：外人不能进入并知晓家里的状况；无法保证完整性，家里东西被改变我无法知道；可以保证可用性，自家人可以进入。
- 右图在安锁的基础上再加装摄像头：可以保证机密性：外人不能进入并知晓家里的状况；可以保证完整性，家里东西的被改变了我可以知道；可以保证可用性，自家人可以进入。

![](images/安全的家.bmp)

# 密码学经典模型

密码学中有四个经典人物：通信方Alice，通信方Bob，主动攻击者Mallory，窃听者Eve。

假设学生Alice喜欢Bob，于是她写了一封信“我喜欢你”，想对Bob表白，如果Alice在不安全的通道中传递这封信，学生Eve截获并查看了这封信，可能就会向老师打小报告；更有甚者，学生Mallory，比如他喜欢Alice，可能就会篡改这封信，改成“我不喜欢你”，学生Bob收到这封被篡改的信后说不定就会伤心欲绝，一段浪漫的爱情故事就被扼杀了。

![经典模型](images/经典模型.png)

密码学提供了各种密码技术来保障Alice和Bob之间交换信息的安全：单向散列算法、对称加密算法、消息认证码、伪随机数生成器、公钥密码算法、数字签名算法等，其关系如下。

![密码技术](images/密码技术.bmp)

# 对称密码

对称加密算法是使用同一把密钥加密明文和解密密文的算法，保障数据的机密性。常见的对称加密算法有AES、DES和SM4等。

## 分组密码算法

对称密码算法一次只能处理固定长度的分组数据，需要进行分组和填充，分组密码模式有：

- ECB模式：将明文分组加密之后直接变成密文分组，已废弃

- CBC模式：首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密，仅解密支持并行计算

- CFB模式：将明文分组与密码算法的输出进行XOR运算来生成密文分组，无需填充，仅解密支持并行计算

- OFB模式：密码算法的输出反馈到密码算法的输入中，无需填充，不支持并行计算

- CTR模式：通过对逐次累加的计数器进行加密来生成密钥流，然后与明文分组进行XOR运算得到密文分组，无需填充，支持并行计算

## AES算法

AES算法是一个对称分组加密算法，分组长度为16字节，密钥长度为128/192/256位。其内部实现操作包括字体替换、行移位、列混合、轮密钥加法。

## 实践测试

以AES128密钥长度分别测试ECB模式、CBC模式和CTR模式。

### AES_ECB

1. 加密

   ```bash
   openssl enc -e -aes-128-ecb -in hello.txt -out cipher.txt -K 000102030405060708090A0B0C0D0E0F -p
   ```

   由于密文是二进制格式，可以用hexdump查看

   ```bash
   hexdump cipher.txt
   # 0000000 f8c3 4aa4 9091 1dd9 a8c7 e3e7 005f 2dcf
   # 0000010
   ```

2. 解密

   ```bash
   openssl enc -d -aes-128-ecb -in cipher.txt -out plain.txt -K 000102030405060708090A0B0C0D0E0F -p
   ```

3. 查看一致

   ```bash
   diff hello.txt plain.txt
   ```

### AES_CBC

1. 加密

   ```bash
   openssl enc -e -aes-128-cbc -in hello.txt -out cipher.txt -K 000102030405060708090A0B0C0D0E0F -iv 00000000000000000000000000000000 -p
   ```

2. 解密

   ```bash
   openssl enc -d -aes-128-cbc -in cipher.txt -out plain.txt -K 000102030405060708090A0B0C0D0E0F -iv 00000000000000000000000000000000 -p
   ```

3. 查看一致

   ```bash
   diff hello.txt plain.txt
   ```

### AES_CTR

1. 加密

   ```bash
   openssl enc -e -aes-128-ctr -in hello.txt -out cipher.txt -K 000102030405060708090A0B0C0D0E0F -iv 00000000000000000000000000000000 -p
   ```

2. 解密

   ```bash
   openssl enc -d -aes-128-ctr -in cipher.txt -out plain.txt -K 000102030405060708090A0B0C0D0E0F -iv 00000000000000000000000000000000 -p
   ```

3. 查看一致

   ```bash
   diff hello.txt plain.txt
   ```

# 单向散列函数

单向散列函数，常称为哈希函数，为消息产生一个“指纹”，用来检测消息的完整性。常见的哈希算法有MD5、SHA2家族（SHA256/SHA384/SHA512）和SM3等。

单向散列函数具有以下性质：输入长度可变，输出长度固定；高效率，能够快速计算出哈希值；消息不同，散列值也不同；单向性，不能通过哈希值推算出消息。

### 应用场景

假定Alice要向Bob传送表白信，具体过程如下

1. Alice准备好表白信
2. Alice使用哈希函数对该信计算消息摘要
3. Alice将信和消息摘要一并发给Bob
4. Bob收到信后使用相同的哈希函数计算摘要值
5. Bob比对收到的消息摘要和计算的消息摘要是否一致，一致则说明信未被篡改

## 无法解决的问题

假设主动攻击者Mallory伪装成Alice，向Bob发送了另外一封信及其散列值，Bob只能通过哈希函数检查这封信的完整性，但是无法判断发送者的身份到底是不是Alice。也即单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。

当Bob确认这封信是否真的属于Alice时，仅靠完整性检测是不够的，还需要进行认证。用于认证的技术包括消息认证码和数字签名。

## 实践测试

### SHA256

```bash
openssl dgst -sha256 hello.txt
# SHA256(hello.txt)= 7509e5bda0c762d2bac7f90d758b5b2263fa01ccbc542ab5e3df163be08e6ca9
```

### SM3

```bash
openssl dgst -sm3 hello.txt
# SM3(hello.txt)= 80b737c798f5bb0d826a987b0289e110d2283bb13d124aba4ec183644a05bb65
```

# 消息认证码

消息认证码（Message Authentication Code）可以用来检测消息的完整性和真实性。消息认证码输入包括消息和共享密钥，输出为固定的数据，称为MAC值、Tag。消息认证码不同于哈希函数，哈希函数输入只有消息本身，而消息认证码还有一个发送方和接收方之间的共享密钥。

## 应用场景

假定Alice要向Bob传送表白信，具体过程如下

1. Alice和Bob事先通过安全的渠道共享密钥
2. Alice使用密钥对表白信计算消息认证码MAC
3. Alice将表白信和MAC值发送给Bob
4. Bob收到表白信后，使用相同的密钥对其计算MAC值
5. Bob对比接收到MAC值和计算的MAC值是否一致，一致则说明信来自Alice且未被篡改

### 消息认证码实现方法

### 哈希函数实现

使用哈希函数实现消息认证码算法，称为HMAC，如HMAC-SHA256。在HMAC算法中，共享密钥和消息都没有长度限制。

### 分组密码实现

使用分组密码CBC模式可以实现消息认证码算法，常见为CBC-MAC，和CMAC。

### 认证加密算法实现

认证加密是同时提供数据机密性和完整性的密码算法，目前应用十分广泛，TLS1.3的标准套件均是采用认证加密形式，常见为CCM和GCM算法。

## 无法解决的问题

### 对第三方证明

消息认证码需要在发送者Alice和接收者Bob之间共享同一个密钥，能够计算正确MAC不只Alice，接收者Bob也行。对第三方而言，Alice或者Bob无法证明是对方计算了MAC值，而不是自己。

### 防止否认

假设Bob收到了包含MAC的消息，它自己能判断该消息确实来自Alice，但是无法向第三方指正。Alice可以否认说“这条消息你Bob自己编的吧”、“说不定Bob你密钥泄露了”。利用数字签名可以实现防止否认。

## 实践测试

### HMAC-SHA256

```bash
openssl dgst -hmac 0123456789 hello.txt
# HMAC-SHA256(hello.txt)= 9a508fb28de804326fa6981304aebe896acfb32293797b234a1a3fa0a332a75d
// 或者
openssl dgst -mac hmac -macopt hexkey:000102030405060708090A0B0C0D0E0F hello.txt
```

#### CMAC

CMAC使用全0分组作为初始向量

```bash
openssl dgst -mac cmac -macopt cipher:aes-128-cbc -macopt hexkey:000102030405060708090A0B0C0D0E0F hello.txt
# CMAC(hello.txt)= eff62406f7a1b40b36c1be979b16473f
```

### GCM/CCM

[enc程序不支持AEAD模式](https://www.openssl.org/docs/man1.1.1/man1/enc.html)

````bash
openssl enc -e -aes-128-gcm -in hello.txt -out cipher.txt -K 000102030405060708090A0B0C0D0E0F -iv 00000000000000000000000000000000 -p
# enc: AEAD ciphers not supported
````

